<body id=b style=margin:0>
<script>
d = document;

// MiniFFT
// =======

// This demo computes a 2D FFT of a 256 x 256px image, and plots it using a logarithmic scale.
// The user can use the mouse and controls to edit the image, and recompute its FFT.

// To compute a 2D FFT, we have to perform a 1D FFT on each line of the image,
// then consider the resulting 1D FFTs as a grid,
// and finally, perform a new 1D FFT every column of that grid.

// For a 256 x 256px image, 512 1D FFTs should be computed, in theory.
// In practice, all the FFTs are symmetrical, so it's possible to compute only a half of them and mirror the result.

// 256 is used many times  in the demo, so we store it in N
N = 256;

// =======

// The miniFFT function computes a 1D FFT for a group of 2^N complex numbers.
// The arrays re represent the real parts and imaginary parts of these numbers.
// It's a JS port of the Cooley-Tukey radix-2 decimation-in-time algorithm.
// When this function is called on a line of pixels, re is the greyscale value of each pixel (values 0-255) and im is an array of zeros.
// This non-recursive implementation was optimized by Kevin Kwok. Thanks to him!

function miniFFT(re, im){
  for (i = 0; i < N; i++){
    for(j = 0, h = i, k = N; k >>= 1; h >>= 1){
      j = (j << 1) | (h & 1);
    }
    if (j > i){
      //re[j] = [re[i], re[i] = re[j]][0]
      //im[j] = [im[i], im[i] = im[j]][0]
      [re[j], re[i], im[j], im[i]] = [re[i], re[j], im[i], im[j]];
    }
  }
  for(hN = 1; hN * 2 <= N; hN *= 2){
    for (i = 0; i < N; i += hN * 2){
      for (j = i; j < i + hN; j++){
        pi = 3.14 * (j - i) / hN;
        cos = Math.cos(pi);
        sin = Math.sin(pi);
        tre =  re[j + hN] * cos + im[j+hN] * sin;
        tim = -re[j + hN] * sin + im[j+hN] * cos;
        re[j + hN] = re[j] - tre;
        im[j + hN] = im[j] - tim;
        re[j] += tre;
        im[j] += tim;
      }
    }
  }
}

// =======

// The fft2d function computes and draws the 2D FFT computation of the source image:

// Here's a schematic of the operations that are done for a 4 x 4px image.
// (the principle is applicable for any other power of 2).
// The pixels of each line are written as letters (A to P).
// The complex numbers contained in the 1D FFT of each line is written as a digit (re1 to re8, im1 to im8).
// The complex numbers contained in the 1D FFT of each column is written as a digit' (re1' to re4', im1' to im4')
// The pixels of the final image are written as a letter' (A' to D').
// Reminder: there are only 8 different complex numbers in the FFT of each line, and only 4 different FFT pixels due to symmetries.

// Original image
// -----------             
// | A B C D |
// | E F G H |
// | I J K L |
// | M N O P |
// -----------             

// Compute the 1D FFT of each line.

// miniFFT([A,B,C,D],[0,0,0,0]) = ([re1,re2,re2,re1],[im1,im2,im2,im1])
// miniFFT([E,F,G,H],[0,0,0,0]) = ([re3,re4,re4,re3],[im3,im4,im4,im3])
// miniFFT([I,J,K,L],[0,0,0,0]) = ([re5,re6,re6,re5],[im5,im6,im6,im4])
// miniFFT([M,N,O,P],[0,0,0,0]) = ([re7,re8,re8,re7],[im7,im8,im8,im7])

// Consider all the lines' 1D FFTs as a grid and compute the 1D FFT of each column.
 
// miniFFT([re1,re3,re5,re7],[im1,im3,im5,im7]) = ([re1',re3',re3',re1'],[re1',re3',re3',re1'])
// miniFFT([re2,re4,re6,re8],[im2,im4,im6,im8]) = ([re2',re4',re4',re2'],[re2',re4',re4',re2'])
// miniFFT([re2,re4,re6,re8],[im2,im4,im6,im8]) = ([re2',re4',re4',re2'],[re2',re4',re4',re2'])
// miniFFT([re1,re3,re5,re7],[im1,im3,im5,im7]) = ([re1',re3',re3',re1'],[re1',re3',re3',re1'])

// Consider all the columns' 1D FFTs as a grid and plot it with a logarithmic scale (because most values are very small or huge).

// -------------
// |A' B' B' A'|
// |C' D' D' C'|
// |C' D' D' C'|
// |A' B' B' A'|
// -------------

// And that's how we usually represent a 2D FFT.
// Note: plotting complex numbers as greyscale pixels implies a loss of information,
// so the resulting image can't be iFFT'd (inverse-FFT'd) back to the first image.
// That's why I didn't make the right side of the canvas drawable.

fft2d = function(){

  // Debug: start chrono.
  // D = new Date();
  
  // Get the source image pixels.
  Z = c.getImageData(0, 0, N, N);
  d = Z.data;
  
  // Create three 256 x 256 2D arrays for real parts and imaginary parts and modulus of our complex numbers.
  re = [];
  im = [];
  fft = [];
  max = 0;
  
  // Call miniFFT on each line of the image.
  for(I = 0; I < N; I++){
    re[I] = [];
    im[I] = [];
    
    // Convert each pixel into a complex number.
    for(J = 0; J < N; J++){
    
      // Fill the real part with the pixels intensity (0 - 255).
      // (we only read the green intensity of the pixel. For greyscale images, R = G = B).
      re[I][J] = d[(I * N + J) * 4];
      
      // Fill the imaginary part with 0.
      im[I][J] = 0;
    }
    
    // Compute 1D FFT.
    miniFFT(re[I], im[I]);
  }
  
  // Create two 128 x 128 2D arrays to store the result of our vertical FFTs.
  // We'll compute only a half of the columns and then mirror the result.
  re2 = [];
  im2 = [];
  
  for(I = 0; I < N / 2; I++){
  
    re2[I] = re2[N - I] = [];
    im2[I] = im2[N - I] = [];
    
    for(J = 0; J < N; J++){
      
      // Fill the arrays with the columns of re and im.
      re2[I][J] = re[J][I];
      im2[I][J] = im[J][I];
    }
    
    // Call miniFFT on each column of re and im.
    miniFFT(re2[I], im2[I]);
      
    fft[I] = fft[N - I] = [];
    
    for(J = 0; J < N; J++){
      
      // Compute the modulus of each complex number.
      fft[I][J] = Math.hypot(re2[I][J], im2[I][J]);
      
      // Remember the max value found.
      max = Math.max(max, fft[I][J]);
    }
  }
  
  // Compute the log of the max value.
  logmax = Math.log(max);
  
  // Create a new image.
  //d2 = new ImageData(N, N);
  
  // Draw each pixel of the 2D FFT divided by the log of the max value.
  // Draw the four symmetries too.
  for(I = 0; I < N / 2; I++){
  
    for(J = 0; J < N / 2; J++){
    
      t1 = (I * N + J) * 4;
      t2 = (I * N + N - J - 1) * 4;
      t3 = ((N - I - 1) * N + J) * 4;
      t4 = ((N - I - 1) * N + N - J - 1) * 4;
    
      if(fft[N / 2 - I])
      d[t1] = d[t1 + 1] = d[t1 + 2] = 
      d[t2] = d[t2 + 1] = d[t2 + 2] = 
      d[t3] = d[t3 + 1] = d[t3 + 2] = 
      d[t4] = d[t4 + 1] = d[t4 + 2] = 
      fft[N / 2 - I][N / 2 - J] / logmax;
      
      d[t1 + 3] =
      d[t2 + 3] =
      d[t3 + 3] =
      d[t4 + 3] =
      N;
    }
  }
  
  c.putImageData(Z, 266, 0);
  
  // Debug: stop chrono
  // console.log(new Date() - D + "ms");
  
}

// =======

// Draw the UI.
b.style.padding = "1em";
d.write("<table><td width=262>Draw here<td>FFT</table><canvas id=a width=522 height=256></canvas><p>round<input type=radio name=rs id=rs checked> square <input type=radio name=rs><p>size <input type=range size=1 min=1 max=20 value=10 id=w><p><input type=reset onmouseup=c.fillStyle='#000';c.fillRect(0,0,N,N);fft2d()>");

// =======

// Init the canvas.
c = a.getContext("2d");

// Draw the image and FFT.
c.fillRect(0, 0, N, N);
c.fillStyle = "#fff";
c.fillRect(118, 118, 20, 20);
fft2d();

// =======

// Inputs

// Reset mouse coordinates.
x = y = 0;

// Click a mouse button.
a.onmousedown = function(e){
  
  // Set line width.
  c.lineWidth = +w.value;
  
  // Set line cap.
  c.lineCap = rs.checked ? "round" : "square";
  
  // Left click = white, right click = black.
  c.strokeStyle = "#fff";
  
  // Draw a small line to make something appear on screen already.
  c.beginPath();
  c.moveTo(x = e.pageX - 14, y = e.pageY - 36);
  c.lineTo(x + 1, y);
  c.stroke();
  
  // Compute FFT2D.
  fft2d();
}

// Move mouse.
a.onmousemove = function(e){
  if(x){
    
    // Draw a line between last x/y and new x/y.
    c.moveTo(x, y);
    c.lineTo(x = e.pageX - 14, y = e.pageY - 36);
    c.stroke();
    
    // Compute FFT2D.
    fft2d();
  }
}

// Reset x/y on mouse release.
a.onmouseup = function(e){
  x = y = 0;
}
</script>